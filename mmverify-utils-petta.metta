!(import! &self lib/lib_he)

(= (is-error-atom $expr)
  (== (car-atom $expr) Error))

(= (find-first-error Nil) ())
(= (find-first-error (Cons $head $tail))
  (if (is-error-atom $head)
    $head
    (find-first-error $tail)))

(= (matchc $space $pattern $query) (collapse (match $space $pattern $query)))

(= (empty-space $space) (matchc $space $atom (remove-atom $space $atom)))

(= (remove-pattern $space $pattern) (let $pattern (match $space $pattern $pattern) (remove-atom $space $pattern)))
(= (remove-patternc $space $pattern) (collapse (let $pattern (match $space $pattern $pattern) (remove-atom $space $pattern))))

(= (remove_from_stack $stack_ptr $stack_len)
  (if (> $stack_len $stack_ptr)
    (let () (remove-pattern &stack ( (Num $stack_ptr) $s )) (remove_from_stack (+ 1 $stack_ptr) $stack_len))
    ()))


(= (match-atom $expr $pattern $rewrite)
   (chain (decons-atom $expr) $ht 
     (unify ($head $tail) $ht 
       (let $pattern $head $rewrite)
       (empty))))

(= (match-atom $expr $pattern $rewrite)
   (chain (decons-atom $expr) $ht 
     (unify ($head $tail) $ht 
       (match-atom $tail $pattern $rewrite)
       (empty))))

(= (match-atom' $expr $pattern $rewrite) (case (match-atom $expr $pattern $rewrite) ( (Empty () ) ( $q $q ) )))

(= (match-atom'' $expr $pattern $rewrite $Empty) (case (match-atom $expr $pattern $rewrite) ( (Empty $Empty) ( $q $q ) )))

(= (update-atom $space $atom $update_pattern)
  (match $space $atom (let () (add-atom $space $update_pattern) (remove-atom $space $atom))))

(= (adjust-state-additive $state $delta)
   (chain (get-state $state) $current
     (change-state! $state (+ $current $delta))))



(: match' (-> (List Atom) $a $a $a))
(= (match' Nil $pattern $rewrite) (empty))
(= (match' (Cons $head $tail) $pattern $rewrite) (let $pattern $head $rewrite))
(= (match' (Cons $head $tail) $pattern $rewrite) (match' $tail $pattern $rewrite))

(= (to-list $expr)
   (if (== $expr ()) Nil
     (Cons (car-atom $expr)
         (to-list (cdr-atom $expr)))))

(= (to-list' $expr $tail)
   (if (== $expr ()) $tail
     (Cons (car-atom $expr)
         (to-list' (cdr-atom $expr) $tail))))

(= (flatten-list Nil) Nil)
(= (flatten-list (Cons $head $tail))
  (case (get-metatype $head)
    ((Expression (to-list' $head (flatten-list $tail)))
     ($_ (Cons $head (flatten-list $tail))))))

(= (from-list Nil) ())
(= (from-list (Cons $head $tail))
   (let $tail-list (from-list $tail)
    (cons-atom $head $tail-list)))

(= (flatten-expr $expr) (from-list (flatten-list (to-list $expr))))

(= (mappend Nil $list) $list)
(= (mappend (Cons $head $tail) $list)
   (Cons $head (mappend $tail $list)))

(= (filter' Nil $predicate) Nil)
(= (filter' (Cons $head $tail) $predicate)
   (let $tail-result (filter' $tail $predicate)
     (if ($predicate $head)
       (Cons $head $tail-result)
       $tail-result)))




(= (map-pairs $list1 $list2 $fn)
   (map-atom $list1 $v1
     (map-atom $list2 $v2
       ($fn $v1 $v2))))

(= (is_var $kb $tok)
  (unify $kb (Var $tok $_ (Type "$v")) True False))

(= (find_vars $kb $stmt)
  (filter-atom $stmt $tok (unify $kb (Var $tok $_ (Type "$v")) True False)))

(: string< (-> String String Bool))
(= (string< $x $y)
   (@< $x $y))

(= (orient_pair $x $y)
   (let ($str_x $str_y) ((repr $x) (repr $y))
     (if (string< $str_x $str_y)
         ($x $y)
         ($y $x))))

(= (lookup_d $kb $x $y) (let ($x' $y') (orient_pair $x $y) (unify $kb (DVar ($x' $y') $_ (Type "$d")) True False)))


(= (dv_check $kb $x $y)
  (if (or
        (== $x $y)
        (not (lookup_d $kb $x $y)))
      (Error ($x $y) "Disjoint variable violation.")
      ()))

(= (check_dv_pairs $kb $x_vars $y_vars)
  (map-atom $x_vars $x
    (map-atom $y_vars $y
      (dv_check $kb $x $y))))

(= (check_dvs $kb $subst $dvs0)
    (let*
      (
        ($results (collapse
          (map-atom $dvs0 $d
            (let*
              (
                (($d1 $d2) $d)
                ($x_vars (match $subst ($d1 $sub1) (find_vars $kb $sub1)))
                ($y_vars (match $subst ($d2 $sub2) (find_vars $kb $sub2)))
              ) (check_dv_pairs $kb $x_vars $y_vars)))))
        ($as_list (to-list $results))
      )
      (find-first-error $as_list)))


(= (add_c $kb $tok)
  (unify $kb (Constant $tok (Type "$c")) (Error (Constant $tok) "Constant already declared.")
    (unify $kb (Var $tok $_ (Type "$v")) (Error (Var $tok) "Trying to declare as a constant an active variable.")
      (add-atom $kb ( Constant $tok (Type "$c") )))))

(= (add_v $kb $tok $level)
  (unify $kb (Var $tok $_ (Type "$v")) (Error (Var $tok) "Var already declared and active.")
    (unify $kb (Constant $tok (Type "$c")) (Error (Constant $tok) "Var already declared as constant.")
      (add-atom $kb ( Var $tok (FSDepth $level) (Type "$v") )))))

(= (add_dv_pair_if_fresh $kb $x $y $level)
  (if (== $x $y) ()
    (let ($ox $oy) (orient_pair $x $y)
      (unify $kb (DVar ($ox $oy) (FSDepth $level) (Type "$d"))
        ()
        (add-atom $kb (DVar ($ox $oy) (FSDepth $level) (Type "$d") ))))))

(= (add_d $kb $varlist $level)
  (map-atom $varlist $x
    (map-atom $varlist $y
      (add_dv_pair_if_fresh $kb $x $y $level))))

(= (add_f $kb $label $typecode $var $level)
  (unify $kb (Var $var $_ (Type "$v"))
    (unify $kb (Constant $typecode (Type "$c"))
      (unify $kb ( (Label $label') FHyp (FSDepth $FSDepth) ( (Typecode $typecode') (FVar $var) (Type "$f") ) )
        (Error ( (Label $label') (Typecode $typecode') (Var $var) ) "Var in $f already typed by an active $f-statement." )
        (let*
          (
            ($flist_entry (to-list (($typecode $var))))
            (() (unify $kb (FList (FSDepth $level) $flist)
              (let $flist' (mappend $flist $flist_entry) (update-atom $kb (FList (FSDepth $level) $flist) (FList (FSDepth $level) $flist')))
              (add-atom $kb (FList (FSDepth $level) $flist_entry))))
          )
            (add-atom $kb ( (Label $label) FHyp (FSDepth $level) ( (Typecode $typecode) (FVar $var) (Type "$f") )))
        )
      )
      (Error (Constant $typecode) "Typecode in $f not declared."))
    (Error (Var $var) "Var in $f not declared."))
)



(= (add_e $kb $label $stmt $level)
  (let*
    (
      ($elist_entry (to-list ($stmt)))
      (() (unify $kb (EList (FSDepth $level) $elist)
        (let $elist' (mappend $elist $elist_entry)
          (update-atom $kb (EList (FSDepth $level) $elist) (EList (FSDepth $level) $elist')))
        (add-atom $kb (EList (FSDepth $level) $elist_entry))))
        (() (println! ("add essential hypothesis:" (label $label) (Statement $stmt) (level $level))))
    )
      (add-atom $kb ( (Label $label) EHyp (FSDepth $level) ( (Statement $stmt) (Type "$e") )))
    )
)

(= (collect_lists_by_depth $unordered_list $current $max $ordered_list)
  (if (> $current $max)
    $ordered_list
    (let $current_list (match-atom'' $unordered_list ($current $list) $list Nil)
      (let () (println! ("collect list:" $current - $current_list))
      (collect_lists_by_depth $unordered_list (+ 1 $current) $max (mappend $ordered_list $current_list))))))

(= (add_mand_var $kb $tok)
  (unify $kb (Var $tok $_ (Type "$v"))
    (unify $kb (MandVar $tok) () (add-atom $kb (MandVar $tok))) ()))

(= (assign_f_hyp_to_var $kb $f_hyp)
  (let ($typecode $var) $f_hyp
    (unify $kb (MandVar $var)
      (let () (remove-atom $kb (MandVar $var)) True)
      False)))

(= (assign_f_hyps $kb Nil) Nil)
(= (assign_f_hyps $kb (Cons $head $tail))
   (let*
    (
      ($tail-result (assign_f_hyps $kb $tail))
      (($typecode $var) $head)
      ($pred (unify $kb (MandVar $var) True False))
    )
      (if (== $pred True)
        (let () (remove-atom $kb (MandVar $var)) (Cons $head $tail-result))
        $tail-result)))


(= (make_assertion $kb $stmt)
  (let*
    (
      ($e_hyps_lists (matchc $kb (EList (FSDepth $level) $elist) ($level $elist)))
      (() (println! ("e_hyps lists:" $e_hyps_lists)))
      ($e_levels (collapse (match-atom' $e_hyps_lists ($l $_) $l)))
      (() (println! ("e_levels:" $e_levels)))
      ($e_max_level (if (== $e_levels (())) 0 (max-atom $e_levels)))
      (() (println! ("max_level of ehyps frame stack:" $e_max_level)))
      ($e_hyps_list (collect_lists_by_depth $e_hyps_lists 1 $e_max_level Nil))
      (() (println! ("e_hyps_list:" $e_hyps_list)))
      ($e_hyps_toks (from-list (flatten-list $e_hyps_list)))
      ($_0 (map-atom $e_hyps_toks $tok (add_mand_var $kb $tok)))
      ($_1 (map-atom $stmt $tok (add_mand_var $kb $tok)))
      ($mand_vars (matchc $kb (MandVar $var) $var))
      (() (println! ("mand_vars:" $mand_vars)))
      ($dvs (matchc $kb (DVar ($x $y) $_ (Type "$d"))
              (unify $kb (MandVar $x)
                (unify $kb (MandVar $y) ($x $y) ()) ())))
      (() (println! ("dvs:" $dvs)))
      ($f_hyps_lists (matchc $kb (FList (FSDepth $level) $flist) ($level $flist)))
      (() (println! ("f_hyps lists:" $f_hyps_lists)))
      ($f_levels (collapse (match-atom' $f_hyps_lists ($l $_) $l)))
      (() (println! ("f_levels:" $f_levels)))
      ($f_max_level (if (== $f_levels (())) 0 (max-atom $f_levels)))
      (() (println! ("max_level of fhyps frame stack:" $f_max_level)))
      ($f_hyps_list (collect_lists_by_depth $f_hyps_lists 1 $f_max_level Nil))
      (() (println! ("f_hyps_list:" $f_hyps_list)))
      ($f_hyps (assign_f_hyps $kb $f_hyps_list))
      (() (println! ("f_hyps:" $f_hyps)))
      ($mand_vars' (matchc $kb (MandVar $var) $var))
      (() (println! ("mand_vars':" $mand_vars')))
      ($_2 (remove-patternc $kb (MandVar $var)))
    ) ( (DVars $dvs) (FHyps (from-list $f_hyps)) (EHyps (from-list $e_hyps_list)) (Statement $stmt) )))

(= (add_a $kb $label $stmt)
  (let*
    (
      (() (println! ("make_assertion" $label - $stmt)))
      (( (DVars $dvs) (FHyps $f_hyps) (EHyps $e_hyps) (Statement $stmt) ) (make_assertion $kb $stmt))
      (() (println! ("gathered assertion data:" $dvs $f_hyps $e_hyps $stmt)))
    )
      (add-atom $kb ( (Label $label) Assertion ( (DVars $dvs) (FHyps $f_hyps) (EHyps $e_hyps) (Statement $stmt) (Type "$a") )))))


(= (add-subst $stack $sp $subst ($typecode $var))
  (let*
    (
      ($sp_val (get-state $sp))
      ($entry (match $stack ((Num $sp_val) $s) $s))
      (($entry0 $entry1:) (decons-atom $entry))
    ) (if (== $entry0 $typecode)
        (let*
          (
            (() (println! ("adding subst" $var $entry1:)))
            (() (add-atom $subst ($var $entry1:)))
            ($_ (adjust-state-additive $sp 1))
          ) ($var $entry1:))
        (Error ( (sp $sp_val) (entry $entry) (typecode $typecode) (var $var) ) "Proof stack entry does not match floating hypothesis."))))

(= (apply_subst_tok $subst $tok)
  (let $res (unify $subst ($tok $sub) $sub $tok) $res))

(= (apply_subst $subst $stmt)
    (flatten-expr (map-atom $stmt $tok (apply_subst_tok $subst $tok))))

(= (check_subst $stack $sp $subst $ehyp)
  (let*
    (
      ($sp_val (get-state $sp))
      ($entry (match $stack ((Num $sp_val) $s) $s))
      ($subst_h (apply_subst $subst $ehyp))
    ) (if (== $entry $subst_h)
        (adjust-state-additive $sp 1)
        (Error ( (sp $sp) (entry $entry) (ehyp $ehyp) (subst_h $subst_h) ) "Proof stack entry does not match essential hypothesis."))))



(= (treat_assertion $kb $stack $sp $label $Data $stack_len)
    (let*
      (
        ($dvars (match-atom' $Data (DVars $dvars) $dvars ))
        ($fhyps (match-atom' $Data (FHyps $fhyps) $fhyps ))
        ($ehyps (match-atom' $Data (EHyps $ehyps) $ehyps ))
        ($statement (match-atom' $Data (Statement $statement) $statement ))
        ($lf (size-atom $fhyps))
        ($le (size-atom $ehyps))
        ($npop (+ $lf $le))
        ($sp_val (- $stack_len $npop))
        (() (println! (stack_len: $stack_len , npop: $npop , sp: $sp_val)))
        (() (if (< $sp_val 0) (Error ((label $label) (npop $npop)) "Stack underflow: proof step requires too many hypotheses") ()))
        ($_0 (change-state! $sp $sp_val))
        ($subst (new-space)) ; ($subst &subst)
        ($_1 (map-atom $fhyps $fhyp (add-subst $stack $sp $subst $fhyp)))
        ($_2 (map-atom $ehyps $ehyp (check_subst $stack $sp $subst $ehyp)))
        ($dv_check (check_dvs $kb $subst $dvars))
        (() (println! (dv_check: $dv_check)))
      )
      (if (is-error-atom $dv_check)
        $dv_check
        (let*
          (
            ($_4 (matchc $stack ( (Num $n) $s ) (if (>= $n $sp_val) (remove-atom $stack ( (Num $n) $s )) ())))
            ($new_conclusion (let $new_conclusion (apply_subst $subst $statement) (let () (add-atom $stack ((Num $sp_val) $new_conclusion)) $new_conclusion)))
            (() (println! (new_conclusion: $new_conclusion)))
          ) ()))))


(= (treat_hypothesis $kb $stack $label $Type $Data $stack_len)
  (unify $kb (ActiveHyp $label)
    (case $Type
      ( (FHyp
          (let* (
            ($typecode (match-atom' $Data (Typecode $t) $t))
            ($var (match-atom' $Data (FVar $v) $v))
          ) (add-atom $stack ((Num $stack_len) ($typecode $var)))))
        (EHyp
          (let $stmt (match-atom' $Data (Statement $s) $s)
            (add-atom $stack ((Num $stack_len) $stmt)))) ))
    (Error (label $label) "The label is the label of a nonactive hypothesis.")))


(= (treat_step $kb $stack $sp $label)
    (let*
      (
        (() (println! (»»» treating label $label)))
        (($Type $Data) (unify $kb ((Label $label) $Type $Data)
          ($Type $Data)
          (unify $kb ((Label $label) $Type (FSDepth $level) $Data)
            ($Type $Data)
            (Error (label $label) "No statement information found for label")))) ;; There are two forms of expression, one with 3 atoms and one with 4, so I just check both.  Hacky fix, but it's nice having the level out of the $Data block.
        ($stack_len (case (matchc $stack ( (Num $n) $s ) $n) ( ( () 0 ) ( $nums (+ 1 (max-atom $nums))) ))) ;; Stack length is used in all cases.
        (() (println! ($Type $label data: $Data)))
      )
      (let ()
        (case $Type
          (
            (FHyp (treat_hypothesis $kb $stack $label $Type $Data $stack_len))
            (EHyp (treat_hypothesis $kb $stack $label $Type $Data $stack_len))
            (Assertion (treat_assertion $kb $stack $sp $label $Data $stack_len))
            (Proof (treat_assertion $kb $stack $sp $label $Data $stack_len))
          ))
        (println! (stack ($label): (matchc $stack $s $s))))
      ))

(= (treat_normal_proof $kb $stack $sp $proof)
    (let*
      (
        (() (println! (Got Proof: $proof)))
        ($_0 (empty-space $stack))
        ($_1 (matchc $kb ((Label $label) FHyp $FSDepth $Data) (add-atom $kb (ActiveHyp $label))))
        ($_2 (matchc $kb ((Label $label) EHyp $FSDepth $Data) (add-atom $kb (ActiveHyp $label))))
        ($step_results (collapse (map-atom $proof $label (treat_step $kb $stack $sp $label))))
        ($as_list (to-list $step_results))
        ($first_error (find-first-error $as_list))
      )
      (let () (remove-patternc $kb (ActiveHyp $_))
        (if (is-error-atom $first_error)
          $first_error
          ()))))

(= (verify $kb $stack $sp $proof $conclusion)
    (let*
      (
        ($proof_result (treat_normal_proof $kb $stack $sp $proof))
      )
      (if (is-error-atom $proof_result)
        (let () (println! (Verification failed: $proof_result)) $proof_result)
        (let*
          (
            ($stack_expr (matchc $stack ( (Num  $n) $f) $f))
            ($empty_check (if (== () $stack_expr) (Error (assertion: $conclusion) "Empty stack at end of proof.") ()))
            ($size_check (if (> (size-atom $stack_expr) 1) (Error ((assertion: $conclusion) (stack: $stack_expr)) "Stack has more than one entry at end of proof.") ()))
            ($stack_top (car-atom $stack_expr))
            (() (println! (Comparing: $stack_top "==" $conclusion)))
            ($match_check (if (== $conclusion $stack_top) () (Error ((assertion: $conclusion) (stack: $stack_expr)) "Stack entry does not match proved assertion.")))
          )
          (if (is-error-atom $empty_check)
            $empty_check
            (if (is-error-atom $size_check)
              $size_check
              (if (is-error-atom $match_check)
                $match_check
                (let () (println! "Correct proof!") $stack_top))))))))
      
(= (add_p $kb $stack $sp $label $stmt $proof $verify_proofs)
  (let*
    (
      (() (println! ""))
      (() (println! (Verifying conclusion ($label) $stmt with proof $proof)))
      ($verify_result (if $verify_proofs (verify $kb $stack $sp $proof $stmt) ()))
      (() (println! ("make_assertion" $label - $stmt))) ;; This could just call add_a.
      (( (DVars $dvs) (FHyps $f_hyps) (EHyps $e_hyps) (Statement $stmt) ) (make_assertion $kb $stmt))
      (() (println! ("gathered assertion data:" $dvs $f_hyps $e_hyps $stmt)))
    )
      (let () (add-atom $kb ( (Label $label) Proof ( (DVars $dvs) (FHyps $f_hyps) (EHyps $e_hyps) (Statement $stmt) (Type "$p") (ProofSequence $proof) ))) $verify_result)))

  
